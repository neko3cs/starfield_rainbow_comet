<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Starfield Rainbow Comet</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        cursor: crosshair;
        /* スマホでの意図しないスクロールや選択を防止 */
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
      }
      #myCanvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.webgpu.js",
          "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.webgpu.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three/webgpu";

      // --- 初期化 ---
      const renderer = new THREE.WebGPURenderer({
        canvas: document.querySelector("#myCanvas"),
        antialias: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000005);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        3000,
      );
      camera.position.set(0, 0, 800);

      // --- 1. 星空（背景） ---
      function createStarfield() {
        const starCount = 2000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount; i++) {
          const r = 1000 + Math.random() * 1000;
          const theta = 2 * Math.PI * Math.random();
          const phi = Math.acos(2 * Math.random() - 1);

          positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i * 3 + 2] = r * Math.cos(phi);
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3),
        );
        const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 2,
          transparent: true,
          opacity: 0.8,
        });

        const stars = new THREE.Points(geometry, material);
        scene.add(stars);
        return stars;
      }
      const starMesh = createStarfield();

      // --- 2. 彗星本体（核） ---
      const ball = new THREE.Mesh(
        new THREE.SphereGeometry(15, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xffffff }),
      );
      scene.add(ball);

      // --- 3. パーティクル管理 ---
      const particles = [];
      const pGeo = new THREE.SphereGeometry(1, 4, 4);

      function createParticle(x, y, z, isExplosion = false) {
        const hue = Math.random();
        const pMat = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(hue, 1.0, 0.6),
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        const p = new THREE.Mesh(pGeo, pMat);
        p.position.set(x, y, z);
        const force = isExplosion ? 15 : 4;
        const vx = (Math.random() - 0.5) * force;
        const vy = (Math.random() - 0.5) * force;
        const vz = (Math.random() - 0.5) * force;
        const life = isExplosion
          ? 1.0 + Math.random()
          : 0.6 + Math.random() * 0.4;
        return { mesh: p, vx, vy, vz, life, initialLife: life };
      }

      function triggerExplosion() {
        for (let i = 0; i < 80; i++) {
          const p = createParticle(
            ball.position.x,
            ball.position.y,
            ball.position.z,
            true,
          );
          scene.add(p.mesh);
          particles.push(p);
        }
      }

      // --- 4. 操作ロジック（マウス＆タッチ共通） ---
      const targetPos = new THREE.Vector3(0, 0, 0);

      function updatePosition(clientX, clientY) {
        const v = new THREE.Vector3(
          (clientX / window.innerWidth) * 2 - 1,
          -(clientY / window.innerHeight) * 2 + 1,
          0.5,
        ).unproject(camera);

        targetPos
          .copy(camera.position)
          .add(v.sub(camera.position).normalize().multiplyScalar(600));
      }

      // マウスイベント
      window.addEventListener("mousemove", (e) => {
        updatePosition(e.clientX, e.clientY);
      });
      window.addEventListener("mousedown", triggerExplosion);

      // タッチイベント（スマホ対応）
      window.addEventListener(
        "touchstart",
        (e) => {
          const touch = e.touches[0];
          updatePosition(touch.clientX, touch.clientY);
          triggerExplosion();
        },
        { passive: false },
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          // スクロールを防止
          if (e.cancelable) e.preventDefault();
          const touch = e.touches[0];
          updatePosition(touch.clientX, touch.clientY);
        },
        { passive: false },
      );

      // --- 5. アニメーションループ ---
      renderer.setAnimationLoop(() => {
        // 彗星をターゲットに滑らかに追従させる
        ball.position.lerp(targetPos, 0.08);

        // 背景の回転
        starMesh.rotation.y += 0.0005;

        // 常に尾を引くパーティクルを生成
        for (let i = 0; i < 5; i++) {
          const p = createParticle(
            ball.position.x,
            ball.position.y,
            ball.position.z,
          );
          scene.add(p.mesh);
          particles.push(p);
        }

        // パーティクルの更新と破棄
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= 0.015;
          p.vy -= 0.03;
          p.mesh.position.x += p.vx;
          p.mesh.position.y += p.vy;
          p.mesh.position.z += p.vz;
          p.mesh.material.opacity = p.life / p.initialLife;
          const s = Math.max(0.1, p.life * 3);
          p.mesh.scale.set(s, s, s);

          if (p.life <= 0) {
            scene.remove(p.mesh);
            p.mesh.geometry.dispose();
            p.mesh.material.dispose();
            particles.splice(i, 1);
          }
        }

        renderer.render(scene, camera);
      });

      // リサイズ対応（スマホの回転対策）
      window.addEventListener("resize", () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      });
    </script>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
  </body>
</html>
